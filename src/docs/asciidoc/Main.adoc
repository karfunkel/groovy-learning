= Groovy Learning
:toclevels: 3
:numbered:
:sectnumlevels: 6
:experimental:
:chapter-label:

== Einleitung

// TODO

== Wie geht's los?

// TODO

== Dein erstes Programm

Was ist eigentlich ein Programm und eine Programmiersprache?

Frei nach Wikipedia ist ein *Computerprogramm* oder kurz *Programm* eine den Regeln einer bestimmten *Programmiersprache*
genügende Folge von *Anweisungen* um bestimmte *Aufgaben oder Probleme* mithilfe eines Computers zu bearbeiten oder zu lösen.

Bist Du nun schlauer? Nein?

Ich versuche es mal einfacher: Ein Programm sagt einem Computer was und wie er etwas tun soll.
So wie ein Kochrezept dir sagt wie Du etwas zubereiten sollst. Damit du ein Kochrezept verstehen kannst musst Du gewisse Dinge können:

- Die Sprache und Grammatik in der es geschrieben ist. (Syntax)
- Was die Anweisungen des Rezepts bedeuten und wie Du sie umsetzten kannst. (Semantik) +
 Also was bedeutet z.B. '1TL Salz hinzufügen' und wie wiege ich '500g Mehl' ab.

Auch ein Computer muss das wissen und können, deshalb gibt es Programmiersprachen und so wie deine Eltern dir deine Muttersprache beibrachten
und erklärten wie man eine Waage bedient, so mussten auch Menschen dem Computer die Programmiersprache beibringen. Denn Computer können
kaum etwas - nur zwei Zahlen zusammen zählen - doch das können sie unglaublich schnell. Alles andere muss ihm beigebracht werden.

Doch das brauchst Du hier nicht zu tun - nur um einem Computer zu sagen was und wie er etwas für dich tun soll musst du lernen was er alles kann.
Und genau deshalb musst Du die selbe Sprachen 'spechen' wie er - und das möchte ich Dir hier zeigen.

Du solltest noch wissen dass ein Computer eigentlich eine ganz andere Sprache spricht, welche für Menschen aber so gut wie unverständlich ist.
Man sagt hierzu *'nativer Code'*. Deshalb muss jede Programmiersprache in nativen Code übersetzt werden. Bei den meisten Programmiersprachen übernimmt
das ein Programm mit dem Namen *'Kompiler'*.

Die Programmiersprache die du hier lernen kannst heisst *+Groovy+* und mit Groovy geschriebene Programme können auf allen
Computern ausgeführt werden, für die es eine Java-Laufzeitumgebung gibt.

Was ist das nun schon wieder? Nun Java ist eine andere (zu Groovy sehr ähnliche) Programmiersprache die aber nicht direkt von Computern
verstandenen nativen Code erzeugt, sondern eine Zwischensprache (Binärcode) benutzt, die zwar noch nicht nativ ist, aber viel einfacher
in nativen Code übersetzt werden kann. Computer mit unterschiedlichen Betriebssystemen und Architekturen sprechen leider auch unterschiedlichen
nativen Code.

Nun gibt es zum Glück für viele verschiedene Systeme Java-Laufzeitumgebungen für Binärcode, die fast wie ein Simultanübersetzer funktionieren
und den Binärcode beim ausführen ganz schnell kompilieren und so umwandeln, dass der Computern nun weiss was Sache ist.
Das hat den Vorteil, dass ein Mensch ein Programm nur einmal kompilieren muss und es trotzdem auf vielen verschiedenen Computerarten ausführbar ist.

=== Konsolenausgabe

Beim Lernen von Programmiersprachen gibt es seit 1974 die Tradition als erstes Programm den Text 'Hallo welt!' möglichst einfach auszugeben.
Deshalb starten wir doch gleich mal damit:

[source,groovy]
.Hallo Welt!
----
print('Hallo Welt!') <1>
----
<1> `print` sagt dass etwas auf der Konsole ausgegeben werden soll. Was man ausgeben möchte schreibt man in Klammern dahinter.
Da dies nun eine Kette an Zeichen sein soll muss auch dies der Computer wissen und deshalb werden Zeichenketten (engl. Strings genannt)
in einfach oder doppelte Anführungszeichen gesetzt. Was der Unterschied ist lernst du später noch.

Hier noch eine leicht andere Version in der nicht nur 'Hallo Welt!' sondern auch noch 'Und Tschüss!' ausgegeben werden soll.

[source,groovy]
.Hallo Welt! Und Tschüss!
----
println('Hallo Welt!') <1>
print 'Und Tschüss!'
----
<1> `println` bedeutet *print line* und sagt dass nun eine ganze Zeile auf der Konsole ausgegeben werden soll und deshalb
werden nachfolgende Ausgaben in eine neue Zeile geschrieben. Wenn du hier nur `print` statt `println` benutzt dann bekommst Du

----
Hallo Welt! Und Tschüss!
----

statt

----
Hallo Welt!
Und Tschüss!
----

Probier es doch mal aus.

[NOTE]
====
Aber warum stehen jetzt in der zweiten Zeile keine Klammern ???

Nun Groovy versucht dem Entwickler das Leben so einfach wie möglich zu machen und erlaubt es in den meisten Fällen
die Klammern wegzulassen. Aber leider nicht in allen. Wenn der Kompiler also seltsame Meldungen ausspuckt könnte es auch daran liegen.

====

=== Variablen

Variablen sind Platzhalter für Werte. Ähnlich Schubladen in die Dinge gelegt werden können.
Variablen benötigen einen *Namen* der gewissen Regeln folgt und einen *Variablentyp*.

==== Namensregeln

Bezeichner können aus folgenden Zeichen bestehen:

- Buchstaben (inklusive Umlaute)
- Ziffern
- Unterstrich
- Währungssymbole (z.B. €, $ usw.)

Das erste Zeichen darf keine Ziffer sein.

Zudem gibt es reservierte Worte wie z.B. `as`, `return` oder `in` die nicht benutzt werden dürfen.
So kann eine Variable nicht `new` heissen - `newValue` hingegen ist wieder in Ordnung.

IMPORTANT: Grundsätzlich ist die Groß-/Kleinschreibung wichtig. Die Variable `meinTest` und `meintest` sind unterschiedlich!

CAUTION: Leerzeichen sind keine gültigen Zeichen!

==== Konventionen

Zusätzlich zu den verbindlichen Regeln haben sich Konventionen entwickelt an die man sich halten sollte - aber nicht zwingend muss:

- Variablennamen beginnen mit einem Kleinbuchstaben: `variable`
- Weitere Worte beginnen mit einem Grossbuchstaben (CamelCase): `meineVariable`
- Es ist unüblich Variablen mit einem Währungszeichen oder Unterstrich zu beginnen
- Es ist empfehlenswert keine Umlaute, Währungszeichen oder Unterstriche in Variablennamen zu benutzen

Im Gegensatz dazu werden Konstanten, also Variablen deren Wert sich nicht mehr verändert, anders notiert:
- Konstantennamen werden komplett in Grossbuchstaben geschrieben: `KONSTANTE`
- Worte werden mit einem Unterstrich getrennt: `MEINE_KONSTANTE`

[NOTE]
====
Um seinen Quellcode gut lesen zu können empfiehlt es sich sprechende Namen zu verwenden, also mit dem Namen beschreiben was
in der Variable drin sein soll.

Statt `i` oder `j` sollte eine Variable eher `zaehler` oder `counter` heissen.
====

==== Variablentypen

Grundsätzlich sind alle Werte in Groovy vom Typ `Object`. In eine Variable vom Typ `Object` kann also alles abgelegt werden.
Deshalb gibt es Groovy das Schlüsselwort `def` was aussagt, dass in diese Variable alles abgelegt werden darf.

Aber wenn eine Variable einen Typ hat, dann können auch nur Werte dieses Typs in ihr abgelegt werden.
So können in eine Variable vom Typ `int` auch nur Ganzzahlen abgelegt werden.

Wie führt man nun eine Variable ein? +
Mit `<typ> <name>` wird eine Variable definiert.
Mit dem Gleichheitszeichen kann nun ein Wert abgelegt werden.
Dies kann auch in einer Zeile zusammen gefasst werden.
Wenn eine Variable einmal existiert können ihr immer wieder Werte zugewiesen und diese auch wieder ausgelesen werden.

[source, groovy]
.Beispiele von Variablenbenutzung
----
def name
name = 'Hans Wurst'
int alter = 498

println alter
println name

alter = 15
println alter
----

===== Welche Typen gibt es?

Von Haus aus bringt Groovy folgende Typen mit:

[cols="1,2,2,2"]
.Standard-Typen
|===
|Name       |Beschreibung                  |Wertebereich                                 |Beispiel

|boolean    |Wahrheitsswert                |true oder false                              |true
|byte       |Ganzzahlen                    |-128 bis 127                                 |(byte)-27
|short      |Ganzzahlen                    |-32768 bis -32767                            |(short)20725
|int        |Ganzzahlen                    |-2147483648 bis 2147483647                   |-1038762**i** +
                                                                                          17**I**
|long       |Ganzzahlen                    |-9223372036854775808 bis 9223372036854775807 |92233720368547**l** +
                                                                                          -2497**L**
|BigInteger |Ganzzahlen                    |Unbegrenzt                                   |922337203685472425072659**g** +
                                                                                          1003**G**
|float      |Fließkommazahl                |+/-3.40282347*10^38^                         |-1.38764**f** +
                                                                                          4.3**F**
|double     |Fließkommazahl                |+/-1.79769313486231570*10^308^               |23.5970**d** +
                                                                                          -432.313**D**
|BigDecimal |Fließkommazahl                |Unbegrenzt                                   |1.2 +
                                                                                          922337203685472425072659.123**g** +
                                                                                          1003.1**G**
|char       |Zeichen                       |Alle Unicode-Zeichen                         |\u2348
|String     |Zeichenkette                  |Zeichenketten bestehend aus Unicode-Zeichen  |'Hallo' +
                                                                                          "Hallo" +
                                                                                          /Hallo/
|List       |Liste an Werten               |-                                            |[] +
                                                                                          [1, 2, 'Hallo']
|Range      |Wertebereich                  |-                                            |-1..3 (-1 bis 3 inklusive) +
                                                                                          -1..<3 (-1 bis 3 exklusive)
|Map        |Schlüssel-Wert-Zuordnung      |-                                            |[:] +
                                                                                          [name: 'Hans', alter: 498]
|===

[NOTE]
====
Ihr habt vielleicht die Buchstaben am Ende der Beispiele gesehen. Die benötigt ihr nur wenn ihr explizit einen Wert des
entsprechenen Typs haben wollt. Groovy versucht bei Werten die Typen möglichst intelligent zu erkennen. Wenn also eine Zahl
z.B. nicht mehr in den Werte Bereich von `int` passt, macht er automatisch ein `long` daraus. +
Zudem werden Werte beim Zuweisen zu einer Variable, wenn möglich, in den Typ der Variable umgewandelt.

[source,groovy]
----
def strecke = 922337203685477580 // dies ergibt ein long in 'strecke'
long alter = 12 // Dies ergibt ebenfalls ein long in 'alter'
----
====

===== Eigene Typen

Man kann auch eigene Variablentypen erstellen - diese werden **Klassen** bzw. **Objekte** genannt. +
Klassen, manchmal auch Objekttypen genannt, sind die Beschreibung, also das Rezept, wie so ein Typ aussieht, also was es für
Eigenschaften und welche Funktionen es hat. +
Instanzen, auch Objekte genannt, sind die tatsächlichen Werte die aus einer Klasse im Speicher des Computers erstellt werden.

Man kan sich das am besten mit Gegenständen aus der Welt vorstellen: +
Ein Apfel hat Eigenschaften (Farbe, Gewicht, Geschmack usw.) und Funktionen die ein Apfel 'tun' kann (Wachsen, Reifen, Faulen usw.).
Die Funktionen können die Eigenschaften verändern, so verändert z.B. ein reifender Apfel seinen Geschmack und die Farbe, beim Wachsen sein Gewicht. +
Klassen können auch Funktionen enthalten die andere Instanzen verändern oder benutzen. +
So könnte ein Messer die Funktion haben einen Apfel zu zerschneiden - ud somit nicht seine Eigenschaften, sondern die des
Apfels verändern. Wenn wir noch einen Schritt weiter gehen, kann die Funktion "schälen" einer Hand die Funktion "schneiden eines
"Messer benutzen um einen Apfel zu schälen und somit seine Eigenschaften zu verändern.

NOTE: Funktionen werden in einigen Programmiersprachen, so auch in Groovy, Methoden genannt.

NOTE: Damit die Welt nicht zu einfach ist werden im Sprachgebrauch häufig Klassen und Objekte gleich verwendet, obwohl es zwei verschiedene Dinge sind.

Groovy liefert viele Klassen mit und über Bibliotheken (Programme die jemand anderes geschrieben hat damit man sie für eigene
Programme verwenden kann) können noch viele mehr hinzugefügt werden. +
Grundsätzlich ist alles in Groovy ein Objekt. Auch ein `int`, also eine Ganzzahl, hat einen Objekttyp im Hintergrund der `Integer` heisst.
Er hat unter anderem als Eigenschaften die Werte MAX_VALUE und MIN_VALUE, welche den kleinst- und größtmöglichen Wert für
`int` enthält und Funktionen wie `floatValue()` welche den Wert in einen Wert vom Typ `float` umwandelt.

Es gibt auch Eigenschaften und Funktionen die sich alle Instanzen einer Klasse teilen. Diese werden **statisch** genannt und mit dem Schlüsselwort `static` markiert. +
Diese können direkt auf dem Namen einer Klasse aufgerufen werden. MAX_VALUE und MIN_VALUE bei Integer sind z.B. solche statischen Eigenschaften, denn die minimalen
und maximalen Werte sind für alle Instanzen von `Integer` gleich. +
Ein Beispiel für eine statische Funktion ist z.b. `Integer.toHexString(45054)` die den Wert in eine hexadezimale Zahl umwandelt und das
Ergebnis `affe` als String zurückliefert.

NOTE: Das hexadezimale Zahlensystem hat als Basis 16, also die Ziffern 0-9 und a-f. Beim Programmieren ist zudem noch das
Binäre Zahlensystem mit den Ziffern 0 und 1 und das Oktale Sysem mit den Ziffern 0-8 gebräuchlich. +
Muss Dich hier aber nicht weiter stören.

===== Null und Autoboxing

Null (nicht das deutsche, sondern das englische Null) ist ein Wert, der die Abwesenheit eines Wertes repräsentiert. Also quasi ein nichts.
Um bei unserem Bild mit der Schublade zu bleiben ist eine Variable mit dem Wert `null` eine leere Schublade. +
Es kann allen Variablentypen zugewiesen werden die eine Klasse repräsentieren - also nach Konvention mit einem Grossbuchstaben beginnen.

Jetzt sagte ich im vorigen Kapitel das alles Klassen sind, also auch `int`. Das war nicht falsch aber auch nicht ganz richtig, denn die
sogenannten primitiven Datentypen `boolean`, `byte`, `short`, `int`, `long`, `char`, `float` und `double` besitzen einen Zwillingstyp der als Klasse
definiert wurde. Diese lauten `Boolean`, `Byte`, `Short`, `Integer`, `Long`, `Character`, `Float` und `Double`.

Der Groovykompiler wandelt im Hintergrund nach Bedarf zwischen den beiden Typmöglichkeiten hin und her, so dass alles nach einem Objekt aussieht.
Das geht aber nur für Werte und nicht für Variablendefinitionen. Dies nennt man Autoboxing.

Wenn eine Variable definiert wird und ihr **kein** initaler Wert zugewiesen wird so bekommt sie einen Standardwert (Defaultwert).
Bei Zahlentypen ist dies `0`, bei `char` das Zeichen mit dem Wert `\0000` und bei `boolean` `false`. Alle anderen Typen bekommen den Wert `null`.

=== Kommentare

Manchmal möchte man Kommentare in den Quellcode schreiben um ihn zu erklären, Gedankengänge fest zu halten oder zu dokumentieren.
Diese Kommentare sollen vom Kompiler ignoriert werden.

Mit `//` beginnt man einen Kommentar, der bis zum Ende der Zeile reicht. Also alles nach `//` wird ignoriert.

[source, groovy]
----
printn "Test" // Dies ist ein Kommentar
----

Wenn man einen Kommentar über mehrere Zeilen schreiben will beginnt man mit `/*` und endet mit `*/`.

[source, groovy]
----
/* Diese ist ein
mehrzeiliger
Kommentar */
----

=== Anweisungen

Mit Variablen allein kann man noch nicht viel tun. Und wenn man eine Programmiersprache mit einer natürlichen Sprache vergleicht,
dann könnten Variablen die Substantive sein. +
Für einen Satz benötigt man aber auch noch Verben, die beschreiben was getan werden soll. Diese Aufgabe übernehmen <<Operatoren>> und Anweisungen.

==== Verzweigungen

Genau wie unser Leben verläuft ein Programm auch nicht immer geradlinig und es gibt Entscheidungen zu treffen. +
Dafür gibt es in Groovy Anweisungen, die Bedingungen auswerten und abhängig davon entscheiden ob das Programm "links oder rechts 'rum gehen" soll.

Wenn Du Hunger hast und was zu Essen kaufen willst, dann schaust Du zuerst ein deinen Geldbeutel:

- Hast Du €3,50 kannst Du Dir einen Döner kaufen
- Ansonsten musst Du hungern.

Um solch eine Entscheidung in einem Programm abbilden zu können gibt es den Verzweigungsanweisung `if else`.

[source, groovy]
.Beispiel if - else
----
if (geld >= 3.50) { <1>
    println "Einen Döner bitte"
} else { <2>
    println "Bin auf Diät"
}
----

<1>  `if` benötigt immer eine Bedingung in runden Klammern und einen Block an Anweisungen wie der Programmablauf weiter
gehen soll falls die Bedingung zutrifft.

<2> Optional kann mit dem Schlüsselwort `else` ein weiterer Block an Anweisungen hinzugefügt werden, der definiert wie das
Programm weiterläuft wenn die Bedingung nicht zutrifft.

Wenn in den Anweisungsblöcken für `if` oder `else` nur eine einzelne Anweisung steht wie im obigen Beispiel, dann kann man die
geschweiften Klammern weglassen:

[source, groovy]
.Beispiel if - else mit nur einer Anweisung
----
if (geld >= 3.50)
    println "Einen Döner bitte"
else
    println "Bin auf Diät"
----

Ein häufiger Fall ist, dass im `else`-Zweig wiederum eine `if`-Anweisung steht, also z.B.

- Hast Du €5,00 oder mehr kannst Du Dir ein Dönermenü kaufen.
- Hast Du €3,50 kannst Du Dir einen Döner kaufen
- Ansonsten musst Du hungern.

[source, groovy]
.Beispiel geschachtelte if - else Anweisungen
----
if (geld >= 5.00) {
    println "Ein Dönermenü bitte"
} else {
    if (geld >= 3.50) {
        println "Einen Döner bitte"
    } else {
        println "Bin auf Diät"
    }
}
----

Da die `if`-Anweisung hier eine einzelne Anweisung ist, kann man auch hier die Klammern weg lassen und das ganze etwas lesbarer schreiben:

[source, groovy]
.Beispiel if - else if - else 
----
if (geld >= 5.00) {
    println "Ein Dönermenü bitte"
} else if (geld >= 3.50) {
    println "Einen Döner bitte"
} else {
    println "Bin auf Diät"
}
----

Und die inneren Klammern kann man in diesem Fall auch weg lassen, da jeder Block ja nur eine Anweisung entält:

[source, groovy]
.Beispiel if - else if - else
----
if (geld >= 5.00)
    println "Ein Dönermenü bitte"
else if (geld >= 3.50)
    println "Einen Döner bitte"
else
    println "Bin auf Diät"
----

// Es fehlt bewußt das switch Statement
// Hinweis auf a?b:c ???

==== Schleifen

Uns Menschen ist es in der Regel lästig das Selbe mehrmals zu tun und ein Programm wird auch nicht unbedingt lesbarer wenn die
gleichen Anweisungen öfters hintereinander auftauchen. Spätestens wenn erst zur Laufzeit klar ist wie oft etwas wiederholt werden
soll, benötigt man eine Anweisung die etwas wiederholt. +
Da dies häufig benutzt wird gibt es hierfür mehrere Möglichkeiten:

===== while

Die `while`-Schleife wiederholt etwas solang eine Bedingung erfüllt ist:

[source,groovy]
.Beispiel while-Schleife
----
def zaehler = 0 <1>
while(zaehler < 5) { <2>
    println zaehler
    zaehler = zaehler + 1
}
----

<1> Die Bedingung, *solange wiederholt* werden soll, steht in Klammern hinter dem Schlüsselwort `while`.
<2> Die Anweisungen, welche wiederholt werden sollen, stehen in einem Anweisungsblock. +
Auch hier gilt wie bei der `if`-Anweisung: Wenn es nur eine Anweisung gibt, können die geschweiften Klammern weg gelassen werden.

===== for

Die `for`-Schleife ist eine Variante der `while`-Schleife und fasst die Bestandteile in einer Zeile zusammen:

[source,groovy]
.Beispiel for-Schleife
----
for(def zaehler = 0; zaehler < 5; zaehler = zaehler + 1) { <1>
    println zaehler <2>
}
----

<1> Nach dem Schlüsselwort `for` werden in Klammern drei Teile, durch einen Strichpunkt getrennt, angegeben: +
Initialisierung: Diese Anweisung wird vor der Schleife einmalig ausgeführt. +
Bedingung: Die Schleife wird wiederholt solange diese Bedingung erfüllt ist. +
Fortsetzung: Diese Anweisung wird *nach* jeder Ausführung eines Schleifendurchgangs ausgeführt.

<2> Die Anweisungen, welche wiederholt werden sollen, stehen in einem Anweisungsblock. +
Auch hier gilt wie bei der `if`-Anweisung: Wenn es nur eine Anweisung gibt, können die geschweiften Klammern weg gelassen werden.

===== times

Da es so oft vorkommt dass man etwas z.B. fünf mal tun möchte gibt es noch eine weitere Möglichkeit:

[source,groovy]
.Beispiel times
----
5.times { def zaehler -> <1>
    println zaehler <2>
}
----

<1> In Groovy besitzen Zahlen die Methode `times`, welche als Parameter eine <<Closure>> bekommt.

<2> Was eine <<Closure>> ist sehen wir später, aber grundsätzlich entspricht sie einem Anweisungsblock. Zusätzlich kann
auch eine <<Closure>> Parameter bekommen, was in diesem Fall genau ein Parameter ist, der angibt in der wievielten Wiederholung
man sich befindet. Diesen benennt man innerhalb der Klammer und beendet die Liste der Parameter mit einem Pfeil `\->`. +
Wenn man diesen nicht benennt bekommt er automatisch den Namen `it`. + Die geschweiften Klammern sind hier immer notwendig.

[source,groovy]
.Beispiel times ohne benannten Parameter.
----
5.times { println it }
----

===== for each

Wenn man Anweisungen für jedes Element einer Sammlung wie z.B. einer Liste oder Range ausführen möchte (dies wird auch Iteration
über eine Liste genannt), kann man dies auch mit einer `while` oder `for`-Schleife tun:

[source,groovy]
.Beispiel for each mit for
----
def list = [1,2,3,4,5] <1>
for(def index = 0; index < list.size(); index = index + 1) { <2>
    def element = list[index] <3>
    println element
}
----

<1> Erzeugung einer Liste der Zahlen eins bis fünf mit dem Namen *list*
<2> Wir wiederholen so lange wie mein aktueller Index in der Liste kleiner als die Größe der Liste ist
<3> Mit dem getAt-Operator wird aus der Liste das Element am aktuellen Index gelesen

Doch gibt es hierzu eine Variante, die leichter ist:

[source,groovy]
.Beispiel for each mit for
----
def list = [1,2,3,4,5]
for(def element: list) { <1>
    println element
}
----

<1> Zuerst wird eine Variable definiert welche das aktuelle Element enthalten soll. Zudem musst, getrennt durch einen Doppelpunkt,
die Liste angegeben werden über die iteriert werden soll.

===== each

Auch hierfür gibt es eine Möglichkeit mit <<Closure>>s:

[source,groovy]
.Beispiel for each mit Closure
----
def list = [1,2,3,4,5]
list.each { def element -> <1>
    println element
}
----

<1> Jede Sammlung besitzt eine Methode `each` welche die übergebene <<Closure>> für jedes Element ausführt.

===== break und continue

Für die `for` und `while` Schleifen, __ aber *nicht* für `times` und `each` __, kann man in den Ablauf der Wiederholung eingreifen.

====== break

`break` bricht den gesamten Ablauf der Schleife ab und springt an die Stellen *nach* der Schleife.

[source,groovy]
.Beispiel break
----
def zaehler = 0
while(true) { <1>
    if(zaehler >= 5)
        break <2>
    println zaehler
    zaehler = zaehler + 1
}
----

<1> Dies ist eine Endlosschleife, da `true` ja immer wahr ist.
<2> Wenn der `zaehler` fünf oder mehr erreicht, springt `break` sofort aus dem Anweisungsblock und beendet die Schleife.

====== continue

`continue` bricht nur den aktuellen Anweisungsblock ab und springt an den *Anfang* des nächsten Schleifendurchgangs.

[source,groovy]
.Beispiel continue
----
for(def zaehler = 0; zaehler < 5; zaehler = zaehler + 1) {
    if(zaehler % 2) <1>
        continue <2>
    println zaehler
}
----

<1> Wenn die Division von `zaehler` durch 2 keinen Rest ergibt, also `zaehler` eine gerade Zahl ist.
<2> Überspringe den Rest des Anweisungsblocks und beginne die nächste Iteration der Schleife.

=== Operatoren

Wir sind Operatoren schon begegnet, dem Zuweisungsoperator `=` im Beispiel: `long alter = 12`. +
Mit long alter wird eine Variable mit dem Namen `alter` und dem Typ `long` definiert und mit dem Zuweisungsoperator `=` wird ihr ein
Wert `12` zugewiesen.

Die meisten Operatoren benötigen zwei Operanden (bei `a * 12` sind die Variable a und der Wert 12 die Operanden, `*` der Operator),
es gibt aber auch Operatoren mit einem oder drei Operanden.

Hier möchte ich Dir die wichtigsten Operatoren zeigen und erklären:

[cols="1,6,2"]
.Nummerische Operatoren
|===
| Operator | Beschreibung                                                        | Beispiele

| =        | Zuweisung eines Wertes zu einer Variablen                           | a = 123 +
                                                                                   a = b
| +        | Addition zweier Werte oder Variablen                                | 12 + 34 +
                                                                                   a + 50 +
                                                                                   'Hans ' + 'Dampf'
| -        | Substraktion zweier Werte oder Variablen                            | 12 - 34 +
                                                                                   a - 50
| *        | Multiplikation zweier Werte oder Variablen                          | 12 * 34 +
                                                                                   a * 50
| /        | Division zweier Werte oder Variablen                                | 12 / 34 +
                                                                                   a / 50
| %        | Berechnet den Rest einer Division zweier Werte oder Variablen       | 12 % 2 +
                                                                                   a % 5
| -        | negiert den Wert oder die Variable                                  | -12 +
                                                                                   -a
| **       | Berechnet die Potenz der Operanden. Also `a**2` berechnet a^2^      | 2*\*5 +
                                                                                   a**2
|===

// TODO: Übung

[NOTE]
====
Mit `showInputDialog` (siehe unten) wird ein Dialogfenster angezeigt, welches ein Anzeigefeld (Label), ein Eingabefeld, einen
__OK__- und einen __Abbrechen__-Knopf besitzt. Nachdem der Benutzer etwas eingegeben hat und _OK_ anklickt, wird der
eingegeben Text als String zurückgeliefert. Wenn er Abbrechen klickt dagegen `null`. +
Hierüber können einfache Abfragen realisiert werden:
[source, groovy]
.Beispiel showInputDialog
----
def name = javax.swing.JOptionPane.showInputDialog('Wie lautet Dein Name?')
----
====

[TIP]
====
*Übung*

Schreibe ein Programm, bei dem der Benutzer im ersten Dialog seinen Vornamen und in einem zweiten seinen Nachnamen angibt.
Gebe den Vornamen und den Nachnamen, getrennt durch ein Leerzeichen, aus (`println`).
====

[TIP]
====
*Übung*

Schreibe ein Programm, bei dem der Benutzer in zwei Dialogen zwei Zahlen angibt.
Gebe die Summe, das Produkt und den Rest der Division der zwei Zahlen aus. +
Das Ergebnis soll so aussehen: +
----
// Eingabe: 4 und 3

Summe: 7
Produkt: 12
Rest: 1
----

====

[cols="1,6,2"]
.Vergleichsoperatoren (liefern `true` oder `false` zurück)
|===
| Operator | Beschreibung                                                                       | Beispiele

| ==       | Prüft ob die Operanden den selben Wert besitzen.                                   | a == 12
| !=       | Prüft ob die Operanden **NICHT** den selben Wert besitzen. Das Gegenteil von `==`. | a != b
| <        | Prüft ob der linke Operanden kleiner dem rechten Operanden ist.                    | a < 12
| \<=      | Prüft ob der linke Operanden kleiner oder gleich dem rechten Operanden ist.        | a \<= b
| >        | Prüft ob der linke Operanden größer dem rechten Operanden ist.                     | a > 12
| >=       | Prüft ob der linke Operanden größer oder gleich dem rechten Operanden ist.         | a >= b
| &&       | Verknüpft zwei binäre Werte durch **UND**. +
             Liefert also nur dann `true` zurück wenn beide Werte `true` sind. +
             Dies wird häufig in Verbindung mit anderen Operationen genutzt. So bedeutet z.B. `a >= 10 && a \<= 20`
             dass der Gesamtausdruck nur `true` liefert wenn a zwischen 10 und 20 liegt (inklusive 10 und 20)
                                                                                                | a >= 10 && a \<= 20
| \|\|     | Verknüpft zwei binäre Werte durch **ODER**. +
             Liefert also nur dann `true` zurück wenn **mindestens einer** der Werte `true` ist.| a < 10 \|\| a > 20
| ^        | Verknüpft zwei binäre Werte durch **EXKLUSIVES ODER**, auch **XOR** genannt. +
             Liefert also nur dann `true` zurück wenn **genau einer** der Werte `true` ist.     | a < 10 ^ b < 10
| !        | Negation. Wenn der Wert `true` ist, liefert die Negation `false` zurück
             und umgekehrt.                                                                     | !(a > b)
| in       | Prüft ob ein Element in Werten oder Variablen vom Typ List, Range, Array oder Map
             enthalten ist.                                                                     | a in [1, 2, 3, 5, 7, 11]
|===

[TIP]
====
*Übung*

Erweite das erste Programm so, dass 'Unbekannt' ausgegeben wird, falls der Benutzer die Eingabe abbricht.
====

[TIP]
====
*Übung*

Schreibe ein Programm, bei dem der Benutzer ein Datum eingibt. +
Gib aus ob das Datum vor diesem oder nach diesem Jahr liegt. +
Wenn es in diesem Jahr liegt, dann gib aus ob es in der ersten oder der zweiten Jahreshälfte liegt.

Eine Zeichenkette (String) kann mit `Date.parse("dd.MM.yyyy", datum)` in ein `Date`-Objekt gewandelt werden.
====

[cols="1,6,2"]
.Kombinierte Operatoren
|===
| Operator | Beschreibung                                                                                               | Beispiele

| +=       | Addiert den rechten Operator zum linken Operator und weist der Variable links den neuen Wert zu.           | a += 12
| -=       | Subtrahiert den rechten Operator vom linken Operator und weist der Variable links den neuen Wert zu.       | a -= 12
| *=       | Multipiziert den rechten Operator mit dem linken Operator und weist der Variable links den neuen Wert zu.  | a *= 12
| /=       | Dividiert den linken Operator mit dem rechten Operator und weist der Variable links den neuen Wert zu.     | a /= 12
| %=       | Berechnet den Rest der Division des linken Operators mit dem rechten Operator und weist der Variable links
             den neuen Wert zu.                                                                                         | a %= 12
| **=      | Berechnet die Potenz des linken Operator mit dem rechten Operator und weist der Variable links den neuen Wert zu.
                                                                                                                        | a **= 12
| ++       | ++ hat nur einen Operanden, der entweder links oder rechts davon stehen kann. In beiden Fällen wird der Wert des
             Operanden um eins erhöht und der Variable des Operanden zugewiesen. Der Unterschied liegt darin welchen Wert
             die Operation zurückliefert: +
             Wenn ++ links vom Operator steht wird zuerst der Wert erhöht und dann der erhöhte Wert zurückgeliefert.+
             Wenn ++ rechts vom Operator steht wird zuerst der Wert zurückgeliefert und dann erhöht.                    | a++
                                                                                                                          ++a
| \--       | \-- hat nur einen Operanden, der entweder links oder rechts davon stehen kann. In beiden Fällen wird der Wert des
             Operanden um eins verringert und der Variable des Operanden zugewiesen. Der Unterschied liegt darin welchen Wert
             die Operation zurückliefert: +
             Wenn -- links vom Operator steht wird zuerst der Wert verringert und dann der verringerte Wert zurückgeliefert.+
             Wenn -- rechts vom Operator steht wird zuerst der Wert zurückgeliefert und dann verringert.                | a--
                                                                                                                          --a
|===


// TODO: Übung

[TIP]
====
*Übung*

Schreibe ein Programm, bei dem der Benutzer eine Reihe an Zahlen, durch Kommas getrennt, eingibt. +
Berechne die Summe, den Maximal- und Minimalwert der Zahlen und gebe sie aus.

Eine Zeichenkette (String) kann mit `input.split(',')*.toInteger()` in eine Liste aus Ganzzahlen umgewandelt werden.
====


[cols="1,4,3"]
.Zugriffsoperatoren
|===
| Operator | Beschreibung                                                                       | Beispiele

| []       | Zugriff auf Werte mit Hilfe eines Index (also einer Position). +
             Indices beginnen immer mit 0. +
             Es ist auch möglich mehrere Indices oder einen Bereich anzugeben. +
             Negative Zahlen sind Indices von Hinten gezählt => -1 ist das letzte, -2 das
             vorletzte Element. +
             Bei Maps kann als Index auch der Schlüssel angegeben werden. | 'Hallo'[1] => 'a' +
                                                                                                  [1,2,3,4][2] => 3 +
                                                                                                  'Hallo'[1,4] => 'ao' +
                                                                                                  [1,2,3,4][1,3] => [2, 4] +
                                                                                                  'Hallo'[1..3] => 'all' +
                                                                                                  [1,2,3,4][2..3] => [3, 4] +
                                                                                                  [key: 'ab']['key'] => 'abc'
| .        | Zugriff auf Werte mit Hilfe eines Namens. +
             Bei Maps kann hier direkt mit Hilfe des Schlüssels zugegriffen werden. +
             Bei Objekten und Klassen kann mit dem Punkt auf deren Elemente (Methoden und Eigenschaften) zugegriffen werden. +
                                                                                                | [key: 'abc'].key => 'abc'
                                                                                                  10.MAX_VALUE => 2147483647
                                                                                                  [:].put('key', 'abc') => [key: 'abc']
                                                                                                  Integer.toHexString(45054) => 'affe'
| ?.       | Null-Sichere Navigation. Wenn in einer Variable `null` steht oder eine Funnktion `null`
             zurückliefert und man nun hierauf versucht auf ein Element zuzugreifen kann der Computer
             nichts damit anfangen, denn auf **Nichts** kann man nun einmal nicht zugreifen. Deshalb
             bekommt man eine Fehlermeldung (java.lang.NullPointerException). +
             Um nun nicht alles vorher prüfen zu müssen gilt für den Null-Safe-Operator: +
             Wenn der linke Operand `null` ist, ist das Ergebnis der gesamten Operation `null`.
             Ansonsten gilt das selbe wie beim `.`-Operator.                                    | [key: null]?.key => null
                                                                                                  null?.put('key', 'abc')
|===

// TODO: .* Operator
// TODO: Übung

[TIP]
====
*Übung*
====


[cols="1,4,3"]
.Konditionaloperatoren
|===
| Operator | Beschreibung                                                                       | Beispiele

| ? :      | Dieser Operator hat drei Operanden, wobei der erste vom Typ `boolean` sein muss. +
             Wenn dieser Operator `true` ist dann liefert die Operation den zweiten Operanden zurück,
             ansonsten den dritten.                                                             | alter < 18 ? 'Kind' : 'Erwachsener'
| ?:       | Der Elvis Operator sieht ganz ähnlich wie der obige Operator aus und ist eine Kurzform
             für eine häufig benutze Variante: `a ?: b` ist das selbe wie `a ? a : b`. +
             Dies ist in Verbindung mit der boolschen Interpreation von Werten (siehe weiter
             unten: <<GroovyTruth, Groovy Truth>>) sehr praktisch um Defaultwerte zu definieren.| int a = b ?: 5
|===

// TODO: Übung

[TIP]
====
*Übung*
====


[cols="1,4,3"]
.Sonstige Operatoren
|===
| Operator | Beschreibung                                                                       | Beispiele

| ()       | Aufrufoperator. Dieser Operator ruft auf einem Objekt die Methode `call` auf (sofern sie es gibt).
             Hiermit werden Funktionen ausgeführt. Wenn z.B. ein Objekt `obj` die Funktion `print`
             besitzt wird mit `obj.doIt()` diese Funktion gestartet. Funktionen können Parameter (auch Argumente genannt)
             übergeben werden. Diese werden zwischend die Klammern geschrieben: `obj.doIt("Hallo vom Objekt")`
                                                                                                | obj.doIt()
                                                                                                  obj.doIt("Blah Blah")
                                                                                                  println("Hallo Welt!")
| ()       | Klammern. Wie in der Mathematik (Punkt vor Strichrechnung) werden Klammern genutzt
             um die Auswertungsreihenfolge (<<Präzedenz>>) von Operatoren zu verändern.
                                                                                                | (a + 1) * 12
| new      | Instanziierungsoperator. Um aus einer Klasse eine Instanz zu erstellen wird das Schlüsselwort
             `new` und der Aufrufoperator verwendet. Es wird hierbei ein Speicherplatz reserviert und eine spezielle
             Initialisierungsmethode (Konstruktor) ausgeführt.
                                                                                                | new MyObject()
                                                                                                  new String('Test')
|===

// TODO: Übung

[TIP]
====
*Übung*
====


==== Präzedenz

Aus der Mathematik weisst du, dass die Reihenfolge von Operatoren ausschlaggebend ist - es ein anderes Ergebnis gibt wenn zuerst
Plus und Minus oder Mal und Geteilt gerechnet wird. Diese Reihenfolge der Auswertung von Operatoren nennt man *Präzedenz*.
Du musst dir dies jetzt nicht merken aber es ist hilfreich diese Reihenfolge zu kennen und gegebenenfalls nachzusehen. +
Es sind hier alle Operatoren aufgelistet - auch welche die hier nicht beschrieben wurden - also nicht wundern.

Hier die Präzedenz in Groovy: +
<op> steht für einen Operanden, wenn nicht klar ist welche Version des Operators gemeint ist

[cols="1,4"]
.Präzedenz
|===
| Priorität | Operator

|  1 | new, (), {}, [], ., .&, .@, ?., *., *:, *<op>, ~, !, (type), <op>++, <op>--
|  2 | **
|  3 | ++<op>, --<op>, +<op>, -<op>
|  4 | *, /, %
|  5 | +, -
|  6 | <<, >>, >>>, .., ..<
|  7 | <, \<=, >, >=, in, instanceof, as
|  8 | ==, !=, \<\=>
|  9 | &
| 10 | ^
| 11 | \|
| 12 | &&
| 13 | \|\|
| 14 | <op>?<op>:<op>, <op>?:<op>
| 15 | =, **=, *=, /=, %=, +=, -=, <\<=, >>=, >>>=, &=, ^=, \|=
|===

[[GroovyTruth]]
=== Groovy Truth

=== Methoden

=== Closures

=== Ordnung im System

// packages und imports

== Kreis im Quadrat

=== GroovyFX

== Felder

// Stub

Notiz: 

Von allen Typen können Felder erstellt werden. Felder (engl. Arrays) sind mehrere Variablen des selben Typs mit dem selben Namen. +
Beim Deklarieren von Feldern muss angegeben werden wieviele Elemente das Feld haben soll. Danach kann über den Index, also die Position im Feld,
auf die einzelnen Elemente zugegriffen werden.

[source, groovy]
----
int[] intArray = new int[4]
intArray[2] = 2
intArray[3] = 3
println intArray[3]          // gibt 3 aus
println intArray             // gibt [0, 2, 3, 0] aus

int intArray2 = [1, 2, 3, 4]
println intArray2            // gibt [1, 2, 3, 4] aus
----

Wenn die Größe eines Felds einmal festgelegt ist kann sie nicht mehr verändert werden.
deshalb werden in Groovy häufiger Listen verwendet.
